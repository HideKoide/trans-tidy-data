## 整然ツール

整然データセットを手に入れたら、それで何ができるだろうか。整然データは、それによって分析が容易になるときにかぎって、価値がある。本節では、整然データセットを入力とし、整然データセットを出力として返す整然ツールについて議論する。整然ツールは、1つのツールの出力が他のツールの入力として使用できるため、便利である。このことにより、問題を解決するために複数のツールを単純かつ容易に組み合わせることができる。さらに、整然データは、変数が一貫した明示的な方法で格納されることを保証する。このことにより、各々のツールは単純なものになる。なぜかと言えば、異なるデータセット構造を扱うためのパラメータのスイスアーミーナイフを必要としないためである。

ツールが雑然になる理由は2つある。すなわち、雑然データセットを入力として受け付ける（雑然入力ツール）か、雑然データセットを出力として生成するか（雑然出力ツール）である。雑然入力ツールは、通常、整然入力ツールより複雑となる。整然化の過程についての部分を含める必要があるためだ。これは、一般的な種類の乱雑データセットには役立つものの、往々にして機能が複雑になり、使用と保守が困難になる。雑然出力ツールは、いらだたしいものであり、分析が遅くなる。簡単に構成できず、あるフォーマットから別のフォーマットに変換する方法について常に考えなければならないためである。本節では、両方の例を見る。

次に、分析に関する3つの重要な構成要素、すなわちデータ操作、可視化、モデル化に関して、整然ツールと雑然ツールの事例を示す。Rに既存の整然ツールが多いことから、Rが提供するツールに特に焦点を当てるが、SAS (SAS Institute Inc. 2013)、SPSS (IBM Corporation 2013) 、Stata (StataCorp 2013) といった他の統計プログラミング環境についても触れる。


### 操作

データ操作 (data manipulation) は、変数ごとの変換（`log`や`sqrt`など）だけでなく、集約、選別、並べ替えを含む。私の経験上、これらはデータ操作における4つの基本動詞である。

* 選別 (filter)：何らかの条件に基づいて観測の部分集合を取り出したり、観測を削除したりする。
* 変換 (transform)：変数を追加または変更する。こうした修正は、1個の変数のみが関わる場合（対数変換など）もあれば、複数の変数が関わる場合（重量と体積からの密度計算など）もある。
* 集約 (aggregate)：複数の値を1個の値に集約する（合計、平均などを行う）。
* 並べ替え (sort)：観測の順序を変更する。

変数を参照するための一貫した手法がある場合、これらの操作はすべて簡単になる。整然データならば、こうすることができる。なぜかと言えば、各変数がそれ自体の列にあるためである。

Rでは、基本パッケージの`subset()`関数で選別ができる。また、基本パッケージの`transform()`関数で変換ができる。これらは入力も出力も整然である。さらに、`aggregate()`関数でグループ単位の集約ができる。これの入力は整然である。単一の集約方法が使用されている場合は、出力も整然となる。`plyr`パッケージは、集約と並べ替えのために、整然な`summarize()`と`arrange()`関数を提供している。

4つの動詞は、“by”という前置詞で修飾することができ、実際にしばしばこの修飾が行われる。グループごとに集約したり、変換したり、部分集合を取り出したりすることが必要になることはしばしばある。例えば、各グループで最大のものを選んだり、繰り返されたものを平均したりすることなどがある。4つの動詞のそれぞれと by 操作子を合わせることで、あるデータフレームの複数の部分集合に対して同時に操作できるようになる。ほとんどのSAS `PROC`は`BY`文を持っており、これによりグループごとの操作が可能になる。そして、これらの入力は一般的に整然である。Rの基本パッケージには`by()`という関数があるが、これは入力こそ整然であるものの、出力は整然でない。出力がリストになるためである。**plyr**パッケージの`ddply()`関数は、これに代わる整然な関数である。

複数のデータセットがある場合、他のツールが必要となる。整然データの利点は、他の整然データセットと組み合わせることが容易なことである。組み合わせに必要になるのは、共通変数の一致させることと新しい列を追加することによって動作する結合演算子 (join operator) だけである。これは、Rの基本パッケージの`merge()`関数、または**plyr**パッケージの`join()`関数で実装されている。これらの演算子を、配列に格納されたデータセットを結合する大変さと比較してみよう。こうした作業では、行列演算が使用できるようになる前に、骨の折れるような整列が必要となるのが通常である。このことにより、誤りが非常に検出しにくくなる。


### 可視化

整然な可視化ツールは、出力が視覚的なものであるため、入力のみが整然であることが必要とされる。ドメイン固有言語は、変数とグラフの美的特性（位置、サイズ、形状、色など）との間の対応関係として可視化を記述できることから、整然データセットの視覚化に特に有効である。これは、グラフィックの文法 (Wilkinson 2005) やRのために特別にあつらえられたグラフィックのレイヤー化された文法 (Wickham 2010) の背後にある考えである。

Rのほとんどのグラフィックに関するツールは、基本パッケージの`plot()`関数、**lattice**の類の図 (Sarkar 2008)、**ggplot2** (Wickham 2009) を含めて、入力が整然である。また、雑然データセットを可視化するための特殊なツールがいくつか存在している。`barplot()`, `matplot()`, `dotchart()`, `mosaicplot()`のように、いくつかの基本パッケージのRの関数は、変数が複数の列に散らばっているような雑然データセットで動作する。同様に、平行座標プロット (Wegman 1990; Inselberg 1985) を使って、各時点を列とするような雑然データセットの時系列グラフを作成することができる。


### モデル化

モデル化は本研究の原動力となっている。ほとんどのモデル化ツールが整然データセットで最もうまく動作するためだ。どの統計用の言語にも、さまざまな変数をつなぎ合わせたものとして、モデルを記述する手段がある。こうした手段は、応答変数を予測変数につなぎ合わせるドメイン固有言語である。

* R (`lm()`): `y ~ a + b + c * d`.
* SAS (`PROC GLM`): `y = a + b + c + d + c * d`.
* SPSS (`glm`): `y BY a b c d / DESIGN a b c d c * d`.
* Stata (`regress`): `y a b c\#d`.

これは、整然データが回帰計算のために内部的に使用される形式であるという意味ではない。標準の線形代数ルーチンに簡単に投入できる数値行列を生成するために、大規模な変換が行われる。よくある変換として、切片列（1が並ぶ列）を追加すること、カテゴリ変数を複数の二値ダミー変数にすること、データをスプライン関数の適切な*基礎*basisに射影することが含まれる。特定の種類の雑然データセットに対してモデリング関数を適用する試みがいくつかある。例えば、SASの`PROC GLM`では、`REPEATED`キーワードが存在する場合、方程式の応答側の複数の変数が反復測定値として解釈される。ビルボードの生データについては、整然データの`rank = week * track`の代わりに`wk1 - xwk76 = track`という形式のモデルを構築することができるだろう。

もう1つの興味深い例が、古典的な対応のあるt検定である。これは、データがどう格納されているかによって、2つの方法で計算できる。データが表14(a)のように格納されている場合、対応のあるt検定はxとyの差の平均に適用されるt検定に過ぎない。表14(b) の形式で格納されている場合、変数を表す固定ダミー変数と各IDのランダム切片からなるような混合効果モデルを当てはめることで同等の結果を得ることができる。

Rの`lme4` (Bates, Maechler, Bolker, and Walker 2014) の表記法におては、これは`value ~ variable + (1 | id)`と表される。どうデータをモデル化しても、同じ結果が得られる。これ以上の情報がなければ、どちらのデータ形式が整然であるかについて述べることはできない。xとyが左右の腕の長さを表す場合は表14(a)が整然になるし、xとyが1日目と10日目の測定値を表す場合は表14(b)が整然になる。

モデルの入力は整然な入力が通常必要となるが、こうした細部への注意はモデルの出力に引き継がれない。予測や推定される係数などの出力は必ずしも整然ではない。このことにより、複数のモデルの結果を組み合わせることが難しくなる。例えば、Rでは、モデルの係数の表現方法のデフォルトは、推定量ごとに変数名を記録するための明示的変数を持たないため、整然ではない。かわりにこうした情報は行名として記録されている。Rでは、行名が一意でなければならないため、多くのモデル（例えば、ブートストラップによる再標本化から出てくるモデルやサブグループから出てくるモデルなど）の係数を結合するには、重要な情報を失わないようにするための回避策が必要となる。これは解析の流れを妨げ、複数のモデルの結果を組み合わせるのを難しくする。今のところ、この問題を解決するパッケージについて、私は認識していない。
