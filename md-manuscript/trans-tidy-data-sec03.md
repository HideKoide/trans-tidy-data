## 雑然データセットの整然化

実際のデータセットは、想像できるほとんどすべての方法で整然データの3つの指針に違反しうるし、実際しばしば違反している。時には即座に分析を開始できるデータセットが得られることもあるが、これは例外であって、いつもそうなるわけではない。本節では、雑然データセットに関する以下の最も一般的な問題5つについて説明する。あわせて、これらの問題への対処方法も説明する。

* 列見出しが、値であって変数名でない。
* 複数の変数が、1つの列に格納されている。
* 変数が、行と列の両方に格納されている。
* 複数の類型の観測の構成単位が、同じ表に格納されている。
* 1つの観測の構成単位が、複数の表に格納されている。

驚くべきことに、ほとんどの雑然データセットは、上で明示的に触れられていないたぐいの雑然さを含んでいるのだが、融解・文字列分割・鋳造といったツールの小規模なセットで整然化可能である。本節では、私が遭遇した実際のデータセットに基づいて、各々の問題について説明し、それらを整然化する手法を示す。完全なデータセットとそれを整然化するために使用したRコードは、https://github.com/hadley/tidy-data からオンラインで入手できる。また、本論文のオンラインの補充資料からも入手できる。

### 列見出しが、値であって変数名でない

ありふれたたぐいの乱雑データセットとして、プレゼンテーション用にデザインされたある種の表型のデータがある。こうしたデータセットでは、変数が行と列の両方を形成し、列見出しは変数名でなく値になっている。私はこうした配列方法を雑然なものと見なしているが、場合によってはこれが非常に便利なこともある。この種のデータセットは、完全に交差した設計においては、記憶容量の面で効率的になる。さらに、希望する操作が行列演算として表現できる場合、計算が非常に効率的になる。このことについては、第6節で詳しく説明する。

表4は、この形式の典型的なデータセットの一部を示したものである。このデータセットは、米国における所得と宗教との関係を調査したもので、米国のシンクタンクであるピュー・リサーチ・センター (Pew Research Center) が作成したレポート<sup>1</sup>から持ってきたものだ。ピュー・リサーチ・センターは、宗教からインターネットまでの幅広い主題に対する態度についてのデータを収集し、この形式のデータセットを載せた数多くのレポートを作成している。

[1] http://religions.pewforum.org/pdf/comparison-Income%20Distribution%20of%20Religious%20Traditions.pdf

| religion                |  &lt;$10k|  $10-20k|  $20-30k|  $30-40k|  $40-50k|  $50-75k|
|:------------------------|---------:|--------:|--------:|--------:|--------:|--------:|
| Agnostic                |        27|       34|       60|       81|       76|      137|
| Atheist                 |        12|       27|       37|       52|       35|       70|
| Buddhist                |        27|       21|       30|       34|       33|       58|
| Catholic                |       418|      617|      732|      670|      638|     1116|
| Don’t know/refused      |        15|       14|       15|       11|       10|       35|
| Evangelical Prot        |       575|      869|     1064|      982|      881|     1486|
| Hindu                   |         1|        9|        7|        9|       11|       34|
| Historically Black Prot |       228|      244|      236|      238|      197|      223|
| Jehovah’s Witness       |        20|       27|       24|       24|       21|       30|
| Jewish                  |        19|       19|       25|       25|       30|       95|

表4：ピュー・フォーラムから取った収入と宗教に関するデータの最初の10行。3列（`$75-100k`, `$100-150k`, `&gt;150k`）が省略されている。

このデータセットには、`religion`（宗教）、`income`（収入）、`frequency`（頻度）という3つの変数がある。これを整然化するには、*融解* (melt) するか、スタックする必要がある。つまり、列を行に変換する必要があるのだ。これは、幅広のデータセットを長くすると表現されることがしばしばある。しかし、こう表現するのは不正確であるから、この言い方は避けたいと思う。融解は、既に変数となっている列のリスト（略して*colvar*と呼ぶ）がパラメータとなっている。まだ変数となっていない他の列は、2つの変数に変換される。すなわち、列見出しの繰り返しを含む`column`（列）という新しい変数と、前は分かれていた列から持ってきた値をつなぎ合わせたものを含む`value`（値）という新しい変数である。このことは、ごく小さなデータセットで表5に示されている。融解の結果は融解された (molten) データセットである。

| row |    a|    b|    c|
|:----|----:|----:|----:|
| A   |    1|    4|    7|
| B   |    2|    5|    8|
| C   |    3|    6|    9|

| row | column |  value|
|:----|:-------|------:|
| A   | a      |      1|
| B   | a      |      2|
| C   | a      |      3|
| A   | b      |      4|
| B   | b      |      5|
| C   | b      |      6|
| A   | c      |      7|
| B   | c      |      8|
| C   | c      |      9|


表5：融解の簡単な例。(a) は`row`という1個のcolvarにより融解され、融解されたデータセットである (b) が得られる。どちらの表も待った同じ情報を表している。異なるのは、保存方法だけである。

ピューのデータセットには、colvarが1つある。それは`religion`（宗教）である。そして、融解により表6が得られる。このデータセットでの役割をよりうまく反映するために、`variable`（変数）の列は`income`（収入）に、`value`（値）の列は`freq`（頻度）に名前を変更してある。この形式は、整然である。なぜかと言えば、各列が変数を表し、各行が観測を表し、さらに、この場合は人口統計上の各構成単位が`religion`（宗教）と`income`（収入）の組み合わせに対応しているからだ。

| religion | income             |  freq|
|:---------|:-------------------|-----:|
| Agnostic | &lt;$10k           |    27|
| Agnostic | $10-20k            |    34|
| Agnostic | $20-30k            |    60|
| Agnostic | $30-40k            |    81|
| Agnostic | $40-50k            |    76|
| Agnostic | $50-75k            |   137|
| Agnostic | $75-100k           |   122|
| Agnostic | $100-150k          |   109|
| Agnostic | &gt;150k           |    84|
| Agnostic | Don’t know/refused |    96|

表6：整然化されたピューの収入と宗教に関する調査のデータセットの最初の10行。`column`（列）の列は`income`（収入）に、`value`（値）の列は`freq`（頻度）に名前を変更してある。


このデータフォーマットのもう1つの一般的な使用法として、時間の経過とともに定期的に観測を記録するものが挙げられる。例えば、表7に示すビルボード (Billboard) データセットには、曲が最初にビルボード・トップ100 (Billboard Top 100) に入った日付が記録されている。ここには、`artist`（アーティスト）、`track`（トラック）、`date.entered`（入った日付）、`rank`（順位）、`week`（週）という変数がある。トップ100に入った後の各週のランクは、`wk1`から`wk75`までの75個の列に記録される。曲がトップ100に入っている期間が75週に満たない場合、残りの列は欠損値で埋められる。この保存形式は整然ではないが、データ入力には便利である。そうしなければ、毎週各曲に独自の行が必要となり、タイトルやアーティストといった曲のメタデータを繰り返さす必要が出てきてしまう。しかし、この保存形式を用いれば、繰り返しが少なくなる。この問題については、3.4節でさらに詳しく説明する。

|  year| artist         | track                   | time | date.entered |  wk1|  wk2|  wk3|
|-----:|:---------------|:------------------------|:-----|:-------------|----:|----:|----:|
|  2000| 2 Pac          | Baby Don’t Cry          | 4:22 | 2000-02-26   |   87|   82|   72|
|  2000| 2Ge+her        | The Hardest Part Of ... | 3:15 | 2000-09-02   |   91|   87|   92|
|  2000| 3 Doors Down   | Kryptonite              | 3:53 | 2000-04-08   |   81|   70|   68|
|  2000| 98`^`0         | Give Me Just One Nig... | 3:24 | 2000-08-19   |   51|   39|   34|
|  2000| A\*Teens       | Dancing Queen           | 3:44 | 2000-07-08   |   97|   97|   96|
|  2000| Aaliyah        | I Don’t Wanna           | 4:15 | 2000-01-29   |   84|   62|   51|
|  2000| Aaliyah        | Try Again               | 4:03 | 2000-03-18   |   59|   53|   38|
|  2000| Adams, Yolanda | Open My Heart           | 5:30 | 2000-08-26   |   76|   76|   74|

表7：2000年のビルボード・トップヒットの最初の8個。他の示されていない列は、`wk4`, `wk5`, ..., `wk75`である。

このデータセットには、`year`（年）、`artist`（アーティスト）、`track`（トラック）、`time`（時間）、`date.entered`（入った日付）というcolvarがある。融解することで表8が得られる。ここで整然化だけでなく、クリーニングを少々実施した。`column`（列）は数を取り出すことで`week`（週）に変換した。また、`date`（日付）を`date.entered`（入った日付）と`week`（週）から算出した。

|  year| artist       | time | track                   | date       |  week|  rank|
|-----:|:-------------|:-----|:------------------------|:-----------|-----:|-----:|
|  2000| 2 Pac        | 4:22 | Baby Don’t Cry          | 2000-02-26 |     1|    87|
|  2000| 2 Pac        | 4:22 | Baby Don’t Cry          | 2000-03-04 |     2|    82|
|  2000| 2 Pac        | 4:22 | Baby Don’t Cry          | 2000-03-11 |     3|    72|
|  2000| 2 Pac        | 4:22 | Baby Don’t Cry          | 2000-03-18 |     4|    77|
|  2000| 2 Pac        | 4:22 | Baby Don’t Cry          | 2000-03-25 |     5|    87|
|  2000| 2 Pac        | 4:22 | Baby Don’t Cry          | 2000-04-01 |     6|    94|
|  2000| 2 Pac        | 4:22 | Baby Don’t Cry          | 2000-04-08 |     7|    99|
|  2000| 2Ge+her      | 3:15 | The Hardest Part Of ... | 2000-09-02 |     1|    91|
|  2000| 2Ge+her      | 3:15 | The Hardest Part Of ... | 2000-09-09 |     2|    87|
|  2000| 2Ge+her      | 3:15 | The Hardest Part Of ... | 2000-09-16 |     3|    92|
|  2000| 3 Doors Down | 3:53 | Kryptonite              | 2000-04-08 |     1|    81|
|  2000| 3 Doors Down | 3:53 | Kryptonite              | 2000-04-15 |     2|    70|
|  2000| 3 Doors Down | 3:53 | Kryptonite              | 2000-04-22 |     3|    68|
|  2000| 3 Doors Down | 3:53 | Kryptonite              | 2000-04-29 |     4|    67|
|  2000| 3 Doors Down | 3:53 | Kryptonite              | 2000-05-06 |     5|    66|

表8：整然化されたビルボードデータセットの最初の15行。`date`（日付）の列は、もともとの表には出てこないが、`date.entered`（入った日付）と`week`（週）から計算できる。



### 複数の変数が、1つの列に格納されている

融解後、`column`（列）変数の名前は、多くの場合、複数の潜在的変数の名称を組み合わせたものになる。このことは、結核（TB）データセットによって示されており、そのサンプルが表9に表されている。このデータセットは、世界保健機関からのものであり、確認された結核症例の数を`country`（国）、`year`（年）、そして、人口統計学上のグループ別に記録している。人口統計学上のグループは`sex`（性別〔男、女〕）と`age`（年齢〔0-14,15-25, 25-34, 35-44, 45-54, 55-64, 不明〕）によって分類されている。

| country |  year|  m014|  m1524|  m2534|  m3544|  m4554|  m5564|  m65|   mu|  f014|
|:--------|-----:|-----:|------:|------:|------:|------:|------:|----:|----:|-----:|
| AD      |  2000|     0|      0|      1|      0|      0|      0|    0|    —|     —|
| AE      |  2000|     2|      4|      4|      6|      5|     12|   10|    —|     3|
| AF      |  2000|    52|    228|    183|    149|    129|     94|   80|    —|    93|
| AG      |  2000|     0|      0|      0|      0|      0|      0|    1|    —|     1|
| AL      |  2000|     2|     19|     21|     14|     24|     19|   16|    —|     3|
| AM      |  2000|     2|    152|    130|    131|     63|     26|   21|    —|     1|
| AN      |  2000|     0|      0|      1|      2|      0|      0|    0|    —|     0|
| AO      |  2000|   186|    999|   1003|    912|    482|    312|  194|    —|   247|
| AR      |  2000|    97|    278|    594|    402|    419|    368|  330|    —|   121|
| AS      |  2000|     —|      —|      —|      —|      1|      1|    —|    —|     —|

表 9：もともとのTBデータセット。男を示す‘m’列のそれぞれに対応して、`f1524`, `f2534`といった女性を示す‘f’列もある。紙幅の関係でこれらの列は示されていない。0と欠損値（—）が混ざっていることに気をつけよう。これはデータ収集の過程に起因するもので、このデータセットにおいては両者を区別することが重要になる。


この形式の列見出しは、多くの場合、何らかの文字 (`.`, `-`, `_`, `:`)で区切られいる。こうした場合は、これらの文字を分割のために用いて、文字列を要素に分けることが可能がである。しかし、そうではないこのデータセットなどの場合は、より入念な文字列処理が必要とある。たとえば、変数名は、単一の複合値を構成要素たる複数の値に変換するルックアップテーブルとマッチさせることができる。

表10(a) はTBデータセットを融解した結果を示し、表10(b) は`column`（列）という1個の列を`age`（年齢）と`sex`（性別）という2つの実際の変数に分割した結果を示している。

| country |  year| column |  cases|
|:--------|-----:|:-------|------:|
| AD      |  2000| m014   |      0|
| AD      |  2000| m1524  |      0|
| AD      |  2000| m2534  |      1|
| AD      |  2000| m3544  |      0|
| AD      |  2000| m4554  |      0|
| AD      |  2000| m5564  |      0|
| AD      |  2000| m65    |      0|
| AE      |  2000| m014   |      2|
| AE      |  2000| m1524  |      4|
| AE      |  2000| m2534  |      4|
| AE      |  2000| m3544  |      6|
| AE      |  2000| m4554  |      5|
| AE      |  2000| m5564  |     12|
| AE      |  2000| m65    |     10|
| AE      |  2000| f014   |      3|

| country |  year| sex | age   |  cases|
|:--------|-----:|:----|:------|------:|
| AD      |  2000| m   | 0-14  |      0|
| AD      |  2000| m   | 15-24 |      0|
| AD      |  2000| m   | 25-34 |      1|
| AD      |  2000| m   | 35-44 |      0|
| AD      |  2000| m   | 45-54 |      0|
| AD      |  2000| m   | 55-64 |      0|
| AD      |  2000| m   | 65+   |      0|
| AE      |  2000| m   | 0-14  |      2|
| AE      |  2000| m   | 15-24 |      4|
| AE      |  2000| m   | 25-34 |      4|
| AE      |  2000| m   | 35-44 |      6|
| AE      |  2000| m   | 45-54 |      5|
| AE      |  2000| m   | 55-64 |     12|
| AE      |  2000| m   | 65+   |     10|
| AE      |  2000| f   | 0-14  |      3|

表10：TBデータセットを整然にするには、最初に融解を実施した上で、`column`（列）列を`age`（年齢）と`sex`（性別）の2つの変数に分ける必要がある。


この形式で値を格納すると、元のデータの別の問題が解決される。我々は、数でなく、率を比較したいのだ。しかし、率を計算するには、人口を知る必要がある。元の形式では、人口という変数を追加するための簡単な手法はない。別の表に格納する必要があるため、人口と数を正確にマッチさせることは困難である。整然形式では、人口と率の変数を追加するのは容易である。単に列を追加するだけだ。

### 変数が、行と列の両方に格納されている

雑然データの最も複雑な形式は、変数が行と列の両方に格納されている状況である。表11は、世界気象気候ネットワーク (Global Historical Climatology Network) からのデータで、メキシコのある気象観測所 (MX17004) における2010年の5か月にわたる毎日の気象データを示している。変数は、単独の列（`id`、`year`〔年〕、`month`〔月〕）、複数列にわたっているもの（`day`〔日〕、d1-d31）、複数行にわたっているもの（`tmin`〔最低気温〕、`tmax`〔最高気温〕）といった形式で存在している。31日に満たない月は、その月の最後の方の日が構造的な欠損値になる。`element`（要素）列は変数ではなく、変数名を格納している。

このデータセットを整然化するには、まずcolvarである`id`、`year`〔年〕、`month`〔月〕と変数名を含む列である`element`（要素）を使って融解する。これにより表12(a) が得られる。体裁のために、欠損値を落とし、欠損を明示的でなく暗黙的に表した。月ごとの日数が分かっていて、明示的欠損値を簡単に再構築できるため、このことは許容される。

このデータセットはほぼ整然化されているが、行に格納されている`tmin`（最低気温）と`tmax`（最高気温）という2種類の変数がある。この例では、他の気象に関する変数である `prcp`（降水量）と`snow`（降雪量）は表示されていない。観測の種類に関する問題を解決するには、鋳造（アンスタック）操作が必要となる。この操作では、`element`（要素）変数を回転して列に戻すことで融解の逆を実行する（表12(b)）。この表の形式は整然である。各列には1つの変数があり、各行は1日の観測を示している。鋳造操作については、Wickham (2007) で詳細に説明されている。


| id      |  year|  month| element |   d1|    d2|    d3|   d4|    d5|   d6|   d7|   d8|
|:--------|-----:|------:|:--------|----:|-----:|-----:|----:|-----:|----:|----:|----:|
| MX17004 |  2010|      1| tmax    |    —|     —|     —|    —|     —|    —|    —|    —|
| MX17004 |  2010|      1| tmin    |    —|     —|     —|    —|     —|    —|    —|    —|
| MX17004 |  2010|      2| tmax    |    —|  27.3|  24.1|    —|     —|    —|    —|    —|
| MX17004 |  2010|      2| tmin    |    —|  14.4|  14.4|    —|     —|    —|    —|    —|
| MX17004 |  2010|      3| tmax    |    —|     —|     —|    —|  32.1|    —|    —|    —|
| MX17004 |  2010|      3| tmin    |    —|     —|     —|    —|  14.2|    —|    —|    —|
| MX17004 |  2010|      4| tmax    |    —|     —|     —|    —|     —|    —|    —|    —|
| MX17004 |  2010|      4| tmin    |    —|     —|     —|    —|     —|    —|    —|    —|
| MX17004 |  2010|      5| tmax    |    —|     —|     —|    —|     —|    —|    —|    —|
| MX17004 |  2010|      5| tmin    |    —|     —|     —|    —|     —|    —|    —|    —|

表11：もともとの天候のデータセット。月の中で可能な日のすべてについて個別の列がある。`d9`列から`d31`列は紙幅の関係で省略されている。

| id      | date       | element |  value|
|:--------|:-----------|:--------|------:|
| MX17004 | 2010-01-30 | tmax    |   27.8|
| MX17004 | 2010-01-30 | tmin    |   14.5|
| MX17004 | 2010-02-02 | tmax    |   27.3|
| MX17004 | 2010-02-02 | tmin    |   14.4|
| MX17004 | 2010-02-03 | tmax    |   24.1|
| MX17004 | 2010-02-03 | tmin    |   14.4|
| MX17004 | 2010-02-11 | tmax    |   29.7|
| MX17004 | 2010-02-11 | tmin    |   13.4|
| MX17004 | 2010-02-23 | tmax    |   29.9|
| MX17004 | 2010-02-23 | tmin    |   10.7|

| id      | date       |  tmax|  tmin|
|:--------|:-----------|-----:|-----:|
| MX17004 | 2010-01-30 |  27.8|  14.5|
| MX17004 | 2010-02-02 |  27.3|  14.4|
| MX17004 | 2010-02-03 |  24.1|  14.4|
| MX17004 | 2010-02-11 |  29.7|  13.4|
| MX17004 | 2010-02-23 |  29.9|  10.7|
| MX17004 | 2010-03-05 |  32.1|  14.2|
| MX17004 | 2010-03-10 |  34.5|  16.8|
| MX17004 | 2010-03-16 |  31.1|  17.6|
| MX17004 | 2010-04-27 |  36.3|  16.7|
| MX17004 | 2010-05-27 |  33.2|  18.2|

表12：(a) 融解された天候のデータセット。これはほとんど整然であるが、値のかわりに、`element`（要素）列が変数の名前を含んでいる。欠損値は紙幅の関係で削ってある。(b) 整然な天候データセット。各行が単一の日付における気象測定を示している。`tmin`（最低気温）と`tmax`（最高気温）という2つの測定された変数がある。それ以外の変数は固定的なものである。


### 複数の類型の観測の構成単位が、同じ表に格納されている

データセットには、さまざまなたぐいの観測の構成単位について、複数のレベルで収集された値が含まれることがある。整然化の間は、各類型の観測の構成単位は、それ独自のテーブルに格納されるべきである。これは、データベースの正規化の考え方と密接に関連している。つまり、データベースの正規化により、個々の事実が単一の場所で表現される。これが行われないと、不一致が発生する可能性がある。

表8に示されているビルボードデータセットには、実際のところ、曲およびその各週の順位という2種類の観測の構成単位が含まれている。このことは、曲に関する事実が重複してることとして現れている。`artist`（アーティスト）と`time`（時間）は、個々の週において、曲ごとに繰り返されている。ビルボードデータセットは、2つのデータセットに分ける必要がある。すなわち、`artist`（アーティスト）、`song name`（曲名）、`time`（時間）を格納する曲データセット、および`week`（週）ごとの`song`（曲）の`rank`（順位）を示す順位データセットである。表13は、これら2つのデータセットを示している。週ごとに、その週に売れた曲の総数や類似の人口統計的情報を記録しているような、週に関する背景情報のデータセットを想定することもできるだろう。


|   id| artist              | track                   | time |
|----:|:--------------------|:------------------------|:-----|
|    1| 2 Pac               | Baby Don’t Cry          | 4:22 |
|    2| 2Ge+her             | The Hardest Part Of ... | 3:15 |
|    3| 3 Doors Down        | Kryptonite              | 3:53 |
|    4| 3 Doors Down        | Loser                   | 4:24 |
|    5| 504 Boyz            | Wobble Wobble           | 3:35 |
|    6| 98`^`0              | Give Me Just One Nig... | 3:24 |
|    7| A\*Teens            | Dancing Queen           | 3:44 |
|    8| Aaliyah             | I Don’t Wanna           | 4:15 |
|    9| Aaliyah             | Try Again               | 4:03 |
|   10| Adams, Yolanda      | Open My Heart           | 5:30 |
|   11| Adkins, Trace       | More                    | 3:05 |
|   12| Aguilera, Christina | Come On Over Baby       | 3:38 |
|   13| Aguilera, Christina | I Turn To You           | 4:00 |
|   14| Aguilera, Christina | What A Girl Wants       | 3:18 |
|   15| Alice Deejay        | Better Off Alone        | 6:50 |

|   id| date       |  rank|
|----:|:-----------|-----:|
|    1| 2000-02-26 |    87|
|    1| 2000-03-04 |    82|
|    1| 2000-03-11 |    72|
|    1| 2000-03-18 |    77|
|    1| 2000-03-25 |    87|
|    1| 2000-04-01 |    94|
|    1| 2000-04-08 |    99|
|    2| 2000-09-02 |    91|
|    2| 2000-09-09 |    87|
|    2| 2000-09-16 |    92|
|    3| 2000-04-08 |    81|
|    3| 2000-04-15 |    70|
|    3| 2000-04-22 |    68|
|    3| 2000-04-29 |    67|
|    3| 2000-05-06 |    66|

表13：曲データセット（左）と順位データセット（右）に分けられ、正規化されたビルボードデータセット。各々のデータセットの最初の15行が示されている。曲データセットからはジャンルが、順位データセットからは週が割愛されている。

正規化は、整然化し、矛盾を排除するのに有用である。しかし、リレーショナルデータを直接扱うデータ解析ツールはほとんどないため、通常、分析では、非正規化をしたりデータセットを1つのテーブルに統合したりすることも必要とされる。


### 1つの観測の構成単位が、複数の表に格納されている

1つの類型の観測の構成単位に関するデータ値が、複数の表や複数のファイルに散らばっていることもしばしばある。こうした表とファイルは、しばしば他の1つの変数によって分割されており、それぞれの表もしくはファイルが1つの年や1つの人を表したり、1つの場所を表したりする。個々の記録の形式が一致しているかぎり、これは修正するのが容易な問題である。

1. ファイルを読み込んで、表のリストにする。
2. 各表に対して、元のファイル名を記した新しい列を追加する（ファイル名が重要な変数の値であることが多いため）。
3. すべての表を結合し、1つの表にする。

**plyr**パッケージを使えば、これはRにおいて何のこともない作業になる。以下のコードは、あるディレクトリ (`data/`) において`.csv`で終わるという正規表現にマッチするファイル名のベクトルを生成する。次に、ベクトルの各要素に対する名前として、もともとのファイル名を付ける。こうするのは、`plyr`が次の段階で名前を保持し、最終的なデータフレームの各行がその出所のファイルでラベル付けされていることを保証するためである。最後に、`ldply()` によりすべてのパスに対してループが繰り返され、CSVファイルを読み込み、結果を単一のデータフレームに結合する。

```
R> paths <- dir("data", pattern = "\\.csv$", full.names = TRUE)
R> names(paths) <- basename(paths)
R> ldply(paths, read.csv, stringsAsFactors = FALSE)
```

単一の表を作成しさえすれば、必要に応じて追加的な整然化を実行できる。この種のクリーニングの例として、米国社会保障庁 (US Social Security Administration) が提供する年ごとの赤ん坊の名付けに関する129個の表を1つのファイルに取りまとめたものがある。これは https://github.com/hadley/data-baby-names で手に入れることができる。

データセットの構造が時とともに変化する場合には、より複雑な状況が発生する。例えば、データセットには、異なる変数、異なる名前の同じ変数、異なるファイル形式、または欠損値に関する異なる規則が含まれる可能性がある。このため、ファイルごとに別々に整然化する必要があるかもしれない（あるいは、運が良ければ小さいグループごとということになるかもしれない）。この種の整然化の例は https://github.com/hadley/data-fuel-economy に示されている。これは、1978年から2008年までの5万台を超えるEPAの燃費データを整然化したものである。この生データはオンラインで入手できるが、年ごとに別々のファイルに保存されており、なおかつ主要な形式だけでも4種類ある上、さらに細かな差異が多数見られる。このため、このデータセットを整然化するのはかなりの難題である。
